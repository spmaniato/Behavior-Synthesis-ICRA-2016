% !TEX root = ../main.tex

We experimentally validated our end-to-end approach in the lab, using Atlas and the software that Team ViGIR developed for the DRC.
Due to a hardware issue, Atlas could not locomote.
Our two demonstrations are presented in the video that accompanies this paper and summarized here.

In the first experimental demonstration, we show how a high-level behavior is specified and synthesized starting from scratch.\footnote{The automatically generated \textsc{ltl} specification for this demo is available at: \scriptsize{\url{https://gist.github.com/spmaniato/a2698db2dee1e11d9b0c}}}
Once the state machine has been instantiated (Fig. \ref{Fig:stand_and_pick_sm}), it is ready for execution (Fig. \ref{Fig:stand_and_pick_gopro}).

\begin{figure}[t]
	\centering
	\begin{subfigure}[b]{0.999\columnwidth}
	\includegraphics[width=0.99\columnwidth,clip]{./img/stand_and_pick_sm.png}
	\caption{
	The state machine above was synthesized for the task with $\mathcal{I} = \{ \mathtt{stand\_prep} \}$ and $\mathcal{G} = \{ \mathtt{look\_down}, \mathtt{pickup\_object} \}$.
	The capability $\mathtt{object\_template}$ requests an object template from the operator (Section \ref{S:TeamViGIR}).
	It is a precondition of $\mathtt{pickup\_object}$
	The corresponding synthesized automaton is the one in Fig. \ref{Fig:SynthesizedAutomaton}.
	}
	\label{Fig:stand_and_pick_sm}
	\end{subfigure}
	
	\vspace{4 pt}
	\begin{subfigure}[b]{0.95\columnwidth}
	\includegraphics[width=0.99\columnwidth, clip]{./img/stand_and_pick_gopro.png}
	\caption{Atlas finishing execution of state $\mathtt{8\_pickup\_object}$.
	} 
	\label{Fig:stand_and_pick_gopro}
	\end{subfigure}
	\caption{
	Snapshots from the first experimental demonstration.
	}
	\label{Fig:stand_and_pick_demo}
	\vspace{-10 pt}
\end{figure}

For the second experimental demonstration, consider a scenario where the operator has designed a state machine that addresses a high-level task (either manually or via synthesis).
Atlas is then deployed and starts carrying out this task.
If, during execution, an \emph{unexpected} situation arises, the operator can use FlexBE's runtime modification capability \cite{Philipp2015MSc} (Fig. \ref{Fig:synthesis_runtime_demo}).
In this case, behavior execution is ``locked" at some state, i.e., this state is prevented from returning an outcome (Fig. \ref{Fig:runtime1}). 
The operator then specifies a new high-level behavior meant to address the unexpected situation.
Once this new state machine is instantiated (Fig. \ref{Fig:runtime2}), it gets connected to the previous one (Fig. \ref{Fig:runtime1}), and execution resumes.
The synthesis process is much faster, compared to manually designing a state machine, and comes with correctness guarantees.

\begin{figure}[t]
	\centering
	\begin{subfigure}[b]{0.99\columnwidth}
	\includegraphics[width=0.99\columnwidth, clip]{./img/synthesis_runtime_connect_sm.png}
	\caption{The operator ``locks" the initial state machine at the state $\mathtt{6\_manipulate}$ (indicated by the orange color), which is allowed to be executed.
	Then, a new state machine, $\mathtt{back\_up}$, is synthesized with $\mathtt{manipulate}$ as the initial condition.
	The transition from $\mathtt{6\_manipulate}$ is then moved from $\mathtt{8\_grasp\_object}$ to $\mathtt{back\_up}$.
	} 
	\label{Fig:runtime1}
	\end{subfigure}
	
	\vspace{4 pt}
	\begin{subfigure}[b]{0.99\columnwidth}
	\includegraphics[width=0.99\columnwidth, clip]{./img/synthesis_runtime_synthesized_sm.png}
	\caption{The new state machine, $\mathtt{back\_up}$, was synthesized for the task with $\mathcal{I} = \{ \mathtt{manipulate} \}$ and $\mathcal{G} = \{ \mathtt{footstep\_execution} \}$.
	} 
	\label{Fig:runtime2}
	\end{subfigure}
	\caption{
	FlexBE Editor snapshots from the second experimental demonstration.
	In response to some event, the operator synthesized a state machine that has Atlas back away (\ref{Fig:runtime2}).
	}
	\label{Fig:synthesis_runtime_demo}
	\vspace{-10 pt}
\end{figure}

% END