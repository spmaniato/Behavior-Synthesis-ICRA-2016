% !TEX root = ../main.tex

\subsection{Multi-Paradigm Specification}\label{S:multi-paradigm}

Specifying a robot task in a formal language can be a time consuming and error prone process.
It also requires an expert user.
To alleviate these issues, we employ a multi-paradigm specification approach. 
We first observe that there are portions of the task specification $\mathcal{T}_\mathcal{S}$ that are going to be system-specific and portions that are going to be task-specific, such as the task's goals.
Intuitively, a non-expert user should only have to specify the goals $\mathcal{G}$ without worrying about the internals of the robot and the software it is running.
We can infer which actions $\mathcal{A}$ are pertinent to a task and use the discrete abstraction $\mathcal{D}$ as the basis for automatically generating the portion of the formal specification that is related to the system itself.
Finally, the initial conditions $\mathcal{I}$ are either specified by the user or detected at runtime.

Thus, referring to Problem \ref{SpecificationProblem}, we get the goals $\mathcal{G}$ and initial conditions $\mathcal{I}$ from a user.
The discrete abstraction $\mathcal{D}$ is system-specific and has been defined \emph{a priori} by the expert system designers, according to Section \ref{S:abstraction}.
We can now automatically generate the task specification $\mathcal{T}_\mathcal{S}$ in (the \textsc{gr(1)} fragment \cite{Bloem2012GR1} of) Linear Temporal Logic.
Since \textsc{ltl} is compositional, we can generate individual formulas and then conjunct them to get the full \textsc{ltl} specification.


\subsection{Specification of Actions and Control Mode Constraints}

Since the activation of capabilities is controlled by the system, the corresponding \textsc{ltl} formulas will be in $\varphi_s$, the safety requirements (see Section \ref{S:GR1}).
Conversely, we do not control the outcome of activation; the adversarial environment does.
Therefore, the \textsc{ltl} formulas specifying the behavior of outcomes will be in $\varphi_e$, the safety assumptions.

\subsubsection{General Formulas}

We say that an activation proposition $\pi_y$, $y \in \{a, m\}$, is $\True$ when the corresponding primitive capability is being activated and $\False$ when it is not being activated\footnote{Note that this is in contrast to the work of Raman, et al. \cite{Vasu2013ICRA}, where, e.g., $\pi_{camera}$ being $\False$ stands for the act of \emph{deactivating} the corresponding primitive capability, i.e., turning a camera off.}.
Therefore, the system safety requirement \eqref{PropositionDeactivationFormula} dictates that all activation propositions $\pi_y \in \mathcal{Y}$ should turn $\False$ once an outcome has been returned.
Note that the left-hand side of formula \eqref{PropositionDeactivationFormula} is only $\True$ at those distinct time steps where an outcome was just returned.

\todo[inline, caption = {Fix proposition ``deactivation" formula}]{This formula is not consistent with the implementation in ReSpeC, even though they might be 100\% equivalent.
Look like I might be able to remove it altogether!}

\begin{equation}\label{PropositionDeactivationFormula}
	\bigwedge \limits_{o \in Out(y)} \LTLG \Big( \pi_y \wedge \LTLX \pi_y^o \Rightarrow \LTLX \lnot \pi_y \Big)
\end{equation}

The environment safety assumption \eqref{OutcomeMutexFormula} dictates that the outcomes, $\pi_y^o$, of the activation of any system capability are mutually exclusive (e.g., an action cannot both succeed and fail).
Formula \eqref{OutcomeMutexFormula} also allows for no outcome being $\True$.

\begin{equation}\label{OutcomeMutexFormula}
	\bigwedge \limits_{o \in Out(y)} \LTLG \Big( \LTLX \pi_y^o \Rightarrow \bigwedge \limits_{o^\prime \neq o} \LTLX \lnot \pi_y^{o^\prime} \Big)
\end{equation}

The environment safety assumption \eqref{ActionOutcomeConstraintFormula} constraints the value of outcomes.
Specifically, it dictates that, if an outcome is $\False$ and the corresponding capability is not being activated, then that outcome should remain $\False$.
It is a generalization of formula (4) in \cite{Vasu2013ICRA}.

\begin{equation}\label{ActionOutcomeConstraintFormula}
	\bigwedge \limits_{o \in Out(y)} \LTLG \Big( \lnot \pi_y^o \wedge \lnot \pi_y \Rightarrow \LTLX \lnot \pi_y^o \Big)
\end{equation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Action-specific Formulas}

The following formulas encode the connection between the activation and the possible outcomes of the system's actions, $a \in \mathcal{A}$.

The environment safety assumption \eqref{ActionOutcomePersistenceFormula} dictates that the value of an outcome should not change if the corresponding action has not been activated again. 
In other words, outcomes persist through time.

\begin{equation}\label{ActionOutcomePersistenceFormula}
	\bigwedge \limits_{o \in Out(a)} \LTLG \Big( \pi_a^o \wedge \lnot \pi_a \Rightarrow \LTLX \pi_a^o \Big)
\end{equation}

The environment liveness assumption \eqref{ActionFairnessConditionsFormula} is a fairness condition.
It states that (always) eventually, the activation of an action will result in an outcome, unless that action is not activated to begin with.
%The disjunct $\lnot \pi_a$ is added in order to prevent situations where the environment loses the game due to the system never activating the action.

\begin{equation}\label{ActionFairnessConditionsFormula}
	\LTLG \LTLF \Big( \Big( \pi_a \wedge \bigvee \limits_{o \in Out(a)} \LTLX \pi_a^o \Big) \vee \lnot \pi_a \Big)
\end{equation}

The system safety requirement \eqref{PreconditionsFormula} constrains the activation of an action $a$ unless its preconditions, $Prec(a)$, are met.

\begin{equation}\label{PreconditionsFormula}
	\LTLG \Big( \bigvee \limits_{y \in Prec(a)} \lnot \pi_y^c \Rightarrow \lnot \pi_a \Big)
\end{equation}
where the superscript $c \in Out(y)$ stands for ``completion".

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Control Mode Formulas}

For brevity of notation, let $$\varphi_m = \pi_m \wedge \bigwedge_{m^\prime \neq m} \lnot \pi_{m^\prime}$$
Activating $\varphi_m$, as opposed to $\pi_m$, takes into account the mutual exclusion between control modes $m \in \mathcal{M}$.
Also let $$\varphi_\mathcal{M}^{none} = \bigwedge_{m \in \mathcal{M}} \lnot \pi_m,$$
where $\varphi_\mathcal{M}^{none}$ being $\True$ stands for not activating any control mode transitions, i.e., staying in the same control mode.

The system safety requirement \eqref{TransitionRelationFormula} encodes the BDI control mode transition system (Section \ref{S:CMActions}, Fig. \ref{Fig:ControlModeTS}) in \textsc{ltl}.

\begin{equation}\label{TransitionRelationFormula}
	\bigwedge \limits_{m \in \mathcal{M}} \LTLG \Big( \LTLX \pi_m^c \Rightarrow \bigvee \limits_{m^\prime \in Adj(m)} \LTLX \varphi_{m^\prime} \vee \LTLX \varphi_\mathcal{M}^{none} \Big)
\end{equation}

The environment safety assumption \eqref{TopologyMutexFormula} enforces mutual exclusion between the BDI control modes.

\begin{equation}\label{TopologyMutexFormula}
	\bigwedge \limits_{m \in \mathcal{M}} \LTLG \Big( \LTLX \pi_m^c \Leftrightarrow \bigwedge \limits_{m^\prime \neq m} \LTLX \lnot \pi_{m^\prime}^c \Big)
\end{equation}

The environment safety assumption \eqref{SingleStepChangeFormula} governs how the active control mode can change (or not) in a single time step, in response to the activation of a control mode transition.

\begin{equation}\label{SingleStepChangeFormula}
	\bigwedge \limits_{m \in \mathcal{M}} \bigwedge \limits_{m^\prime \in Adj(m)} \LTLG \Big( \pi_m^c \wedge  \varphi_{m^\prime} \Rightarrow \big( \LTLX \pi_{m}^c \bigvee \limits_{o \in Out(m^\prime)} \LTLX \pi_{m^\prime}^o \big) \Big)
\end{equation}

Similar to \eqref{ActionOutcomePersistenceFormula}, the environment safety assumption \eqref{TopologyOutcomePersistenceFormula} dictates that the value of the outcomes of control mode transitions must not change if no transition is being activated.

\begin{equation}\label{TopologyOutcomePersistenceFormula}
	\bigwedge \limits_{m \in \mathcal{M}} \bigwedge \limits_{o \in Out(m)} \LTLG \Big( \pi_m^o \wedge \varphi_\mathcal{M}^{none} \Rightarrow \LTLX \pi_m^o \Big)
\end{equation}

The environment liveness assumption \eqref{TopologyFairnessConditionsFormula} is the equivalent of the fairness condition \eqref{ActionFairnessConditionsFormula} for control modes.
A single formula suffices for mutually exclusive propositions \cite{Vasu2013ICRA}.

\begin{equation}\label{TopologyFairnessConditionsFormula}
	\LTLG \LTLF \Big( \bigvee \limits_{m \in \mathcal{M}} \Big( \varphi_m \wedge \bigvee \limits_{o \in Out(m)} \LTLX \pi_m^o \Big) \vee \varphi_\mathcal{M}^{none} \Big)
\end{equation}

This concludes the system-specific portion of $\mathcal{T_S}$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Specification of Task Goals}\label{S:ltl-goals}

Motivated by the DRC tasks, we present formulas that encode the accomplishment of each goal once.
However, \textsc{ltl} can naturally handle repeating tasks (e.g. patrolling).
We can even combine the two paradigms, e.g.,
``Accomplish the goals $\mathcal{G}$ infinitely often, but if anything fails, abort".

The system safety requirements \eqref{MemoryFormula} - \eqref{SMOutcomePersistenceFormula} and liveness requirement \eqref{SuccessLivenessFormula} specify the achievement of the user-provided goals, $g \in \mathcal{G}$, over a finite run (using the same \textsc{ltl} semantics as for infinite execution).
In this paradigm, we say that the execution itself has outcomes too.
We denote them by $o \in Out(Exec)$ and, for simplicity, $Out(Exec) = \{ c, f \}$.
Note that the propositions corresponding to these outcomes, $\pi_{Exec}^o$, are system, not environment, propositions.
We also introduce auxiliary system propositions, $\mu_g$, which serve as memory of having accomplished each goal $g \in \mathcal{G}$.

\begin{equation}\label{MemoryFormula}
	\bigwedge \limits_{g \in \mathcal{G}} \LTLG \big( \LTLX \pi_g^c \vee \mu_g \Leftrightarrow \LTLX \mu_g \big)
\end{equation}

\begin{subequations}
	\label{SMOutcomeFormulas}
	\begin{align}
		\LTLG \Big( \pi_{Exec}^{c} &\Leftrightarrow \bigwedge \limits_{g \in \mathcal{G}} \mu_g \Big) \label{SuccessfulOutcomeFormula}\\
		\LTLG \Big( \pi_{Exec}^{f} &\Leftrightarrow \bigvee \limits_{\pi \in \mathcal{Y}} \pi^f \Big) \label{FailedOutcomeFormula}	 
	\end{align}
\end{subequations}

\begin{equation}\label{SMOutcomePersistenceFormula}
	\bigwedge \limits_{o \in Out(Exec)} \LTLG \Big( \pi_{Exec}^{o} \Rightarrow \LTLX \pi_{Exec}^{o} \Big)
\end{equation}

\begin{equation}\label{SuccessLivenessFormula}
	\LTLG \LTLF \big( \bigvee \limits_{o \in Out(Exec)} \pi_{Exec}^{o} \big)
\end{equation}
The formulas above can be interpreted as: ``If nothing fails, then eventually accomplish each goal. Otherwise, abort".
That is, we assume that the desired reaction to failure $\mathcal{F}$ in Problem \ref{SpecificationProblem} is to stop execution.
While this may sound simplistic and overly conservative, it is actually in line with real-world settings.
For example, NASA JPL's Mars rovers automatically terminate an autonomous drive if the activation of any actuators results in excessive motor current, rover tilt, wheel slip, etc \cite{MER2006Aero}.
Of course this is but one option; the system designers can specify different reactions to failure.

Formula \eqref{MemoryFormula} does not guarantee that the goals will be achieved in a specific order.
However, that is often desirable.
To this end, we can define the goals as an ordered set $\mathcal{G} = \{ g_1, g_2, \ldots, g_n \}$, where $g_i < g_j$ for $i<j$, and the relation $g_i < g_j$ means that goal $g_i$ has to be achieved before $g_j$.
With this definition, we can replace the safety requirement \eqref{MemoryFormula} with \eqref{GoalOrderFormula}, whenever strict goal order is desired.

\begin{equation}\label{GoalOrderFormula}
%	\bigwedge \limits_{i = 1}^n \LTLG \Big(  \lnot \mu_{g_{i-1}} \Rightarrow \LTLX \lnot \mu_{g_i} \Big), \; \mu_{g_0} \triangleq \True
	\bigwedge \limits_{i = 1}^n \LTLG \big( (\pi_{g_i} \wedge \LTLX \pi_{g_i}^c) \wedge \mu_{g_{i-1}} \vee \mu_{g_i} \Leftrightarrow \LTLX \mu_{g_i} \big),
\end{equation}
where $\mu_{g_0} \triangleq \True$.
Formula \eqref{GoalOrderFormula} forces the system to carry out goal $g_i$ after it has accomplished goal $g_{i-1}$.
It can still activate the capability corresponding to $\pi_{g_i}$ earlier, as necessitated by other parts of the task, but that will not count towards achievement of $g_i$ (indicated by $\mu_{g_i}$ being $\True$).

Finally, these auxiliary propositions (memory and outcomes of the run) are added to the system propositions: $$\mathcal{Y} = \mathcal{Y} \cup \bigcup \limits_{g \in \mathcal{G}} \mu_g \cup \bigcup \limits_{o \in Out(Exec)} \pi_{Exec}^o$$

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Specification of Initial Conditions}

%So far, we have handled the system-specific portion of $\mathcal{T_S}$ and the user-specified task goals, $\mathcal{G}$.
%All that is left is the automatic generation of formulas for the task's initial conditions, $\mathcal{I}$.
For each action $a$ and control mode $m$ in the initial conditions $\mathcal{I}$, the completion proposition should be $\True$ in the environment initial conditions \eqref{EnvironmentInitialConditions}.
All other outcome propositions should be $\False$.

\begin{equation}\label{EnvironmentInitialConditions}
	\varphi_i^e = \bigwedge \limits_{i \in \mathcal{I}} \Big( \pi_i^c \bigwedge \limits_{o \in Out(i)\backslash \{c\}} \lnot \pi_i^o \Big) \wedge \bigwedge \limits_{j \not\in \mathcal{I}} \bigwedge \limits_{o \in Out(j)} \lnot \pi_j^o
\end{equation}

Activation propositions are $\False$ regardless of whether that capability is in $\mathcal{I}$ or not because, if something is already an initial condition, then the resulting plan should not activate it at the beginning of execution.
The auxiliary propositions are also $\False$.
Essentially, all $\pi \in \mathcal{Y}$ are initially $\False$:

\begin{equation}\label{SystemInitialConditions}
	\varphi_i^s = \bigwedge \limits_{i \in \mathcal{I}} \lnot \pi_i \wedge \bigwedge \limits_{j \not \in \mathcal{I}} \lnot \pi_j \bigwedge \limits_{g \in \mathcal{G}} \lnot \mu_g \bigwedge \limits_{o \in Out(Exec)} \lnot \pi_{Exec}^{o}
\end{equation}

%END