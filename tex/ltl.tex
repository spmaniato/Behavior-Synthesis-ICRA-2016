% !TEX root = ../main.tex

\subsection{Multi-Paradigm Specification}

\ldots

\subsection{Discrete Abstraction \& Proposition Grounding}

\todo[inline, caption = {Activation--Outcomes or just Completion-Failure ?}]{Write LTL formulas in terms of any possible outcome, $o \in Out(a)$, or only of completion and failure, $\{c, f\}$?}

\begin{subequations}
	\begin{align}
		\mathcal{Y} &= \mathcal{A} \cup \mathcal{M}\\
		\mathcal{X}^\prime &= \mathcal{X} \cup \bigcup \limits_{a \in \mathcal{A}} \bigcup \limits_{o \in Out(a)} \pi_a^o \bigcup \limits_{m \in \mathcal{M}} \bigcup \limits_{o \in Out(m)} \pi_m^o
	\end{align}
\end{subequations}

\subsection{LTL Specification for ATLAS}

\subsubsection{Generic Formulas}

The system safety requirements \eqref{PropositionDeactivationFormula} dictate that an activation proposition should turn \texttt{False} once an outcome has been returned.

\begin{equation}\label{PropositionDeactivationFormula}
	\bigwedge \limits_{o \in Out(a)} \LTLG \Big( \pi_a \wedge \LTLX \pi_a^o \Rightarrow \LTLX \lnot \pi_a \Big)
\end{equation}

The environment safety assumptions \eqref{OutcomeMutexFormula} dictate that the outcomes of an action are mutually exclusive. 
For example, an action cannot both succeed and fail.

\begin{equation}\label{OutcomeMutexFormula}
	\bigwedge \limits_{o \in Out(a)} \LTLG \Big( \LTLX \pi_a^o \Rightarrow \bigwedge \limits_{o^\prime \neq o} \LTLX \lnot \pi_a^{o^\prime} \Big)
\end{equation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Action-specific Formulas}

The environment safety assumptions \eqref{ActionOutcomeConstraintsFormula} govern the value of outcomes in the next time step. 
Specifically, formula \eqref{ActionOutcomeConstraintsFormula3} says that if an outcome has been returned, and the corresponding action is re-activated, then any outcome can become \texttt{True}. 
Formula \eqref{ActionOutcomeConstraintsFormula4} dictates that, if an outcome is \texttt{False} and the corresponding action is not activated, then that outcome should remain \texttt{False}.
This pair of formulas is a generalization of the ``fast-slow" formulas (3) and (4) in \cite{Vasu2013ICRA}.
\todo[inline, caption = {Fix Action Outcome Constraints Formula \eqref{ActionOutcomeConstraintsFormula3}}]{Formula \eqref{ActionOutcomeConstraintsFormula3} is outdated. It doesn't account for the activation--deactivation paradigm!}

\begin{subequations}
	\label{ActionOutcomeConstraintsFormula}
	\begin{align}
		\LTLG& \Big( \bigvee \pi_a^o \wedge \pi_a \Rightarrow \bigvee \LTLX \pi_a^o \Big)\label{ActionOutcomeConstraintsFormula3}\\
		\bigwedge \limits_{o \in Out(a)} \LTLG& \Big( \lnot \pi_a^o \wedge \lnot \pi_a \Rightarrow \LTLX \lnot \pi_a^o \Big)\label{ActionOutcomeConstraintsFormula4}
	\end{align}
\end{subequations}

The environment safety assumptions \eqref{ActionOutcomePersistenceFormula} dictate that the value of an outcome should not change if the corresponding action has not been activated again. 
In other words, the outcome persists.

\begin{equation}\label{ActionOutcomePersistenceFormula}
	\bigwedge \limits_{o \in Out(a)} \LTLG \Big( \pi_a^o \wedge \lnot \pi_a \Rightarrow \LTLX \pi_a^o \Big)
\end{equation}

The environment liveness assumption \eqref{ActionFairnessConditionsFormula} is a fairness condition.
It states that, (always) eventually, either the activation of an action will return an outcome, \eqref{ActionFairnessConditionsFormula1}, or that the robot will ``change its mind", \eqref{ActionFairnessConditionsFormula2}.
Formula \eqref{ActionFairnessConditionsFormula1} is a generalization of $\varphi_a^{completion}$ in \cite{Vasu2013ICRA}, whereas formula \eqref{ActionFairnessConditionsFormula2} is exactly the same as $\varphi_a^{change}$ in \cite{Vasu2013ICRA}, since it consists of activation propositions only.

\begin{subequations}
	\begin{align}
		\varphi_a^{return} = \Big( \pi_a \wedge \bigvee \LTLX \pi_a^o \Big) &\vee \Big( \lnot \pi_a \wedge \bigwedge \LTLX \lnot \pi_a^o \Big)\label{ActionFairnessConditionsFormula1}\\
		\varphi_a^{change} = \big( \pi_a \wedge \LTLX \lnot \pi_a \big) &\vee \big( \lnot \pi_a \wedge \LTLX \pi_a \big)\label{ActionFairnessConditionsFormula2}\\
		\LTLG \LTLF \big( \varphi_a^{return} &\vee \varphi_a^{change} \big)\label{ActionFairnessConditionsFormula}
	\end{align}
\end{subequations}

The system safety requirement \eqref{PreconditionsFormula} demonstrates how a formula encoding the preconditions of an action, $Pre(a)$, looks like in the activation--outcomes paradigm.
\todo[inline, caption = {Procedure for recursively adding preconditions}]{Demonstrate how, given partial specification, we can bring in only those actions and modes that are necessary.}

\begin{equation}\label{PreconditionsFormula}
	\LTLG \big( \bigvee \limits_{p \in Pre(a)} \lnot \pi_p^c \Rightarrow \lnot \pi_a \big)
\end{equation}
where the superscript $c \in Out(p)$ stands for ``completion".

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Control Mode Formulas}

The system safety requirements \eqref{TransitionRelationFormula} encode a topological transition relation, such the BDI control mode transition system.


\begin{equation}\label{TransitionRelationFormula}
	\bigwedge \limits_{m \in \mathcal{M}} \LTLG \Big( \LTLX \pi_m^c \Rightarrow \bigvee \limits_{m^\prime \in Adj(m)} \LTLX \varphi_{m^\prime} \vee \LTLX \varphi_\mathcal{M}^{none} \Big)
\end{equation}
where $\varphi_\mathcal{M}^{none} = \bigwedge \limits_{m \in \mathcal{M}} \lnot \pi_m$ being \texttt{True} stands for not activating any control mode transitions.

The environment safety assumptions \eqref{TopologyMutexFormula} enforce mutual exclusion between the BDI control modes.
\todo[inline, caption = {How to write control mode MutEx formula}]{This formula requires the $\LTLX$ operators to synthesize properly (slugs), but intuitively, they shouldn't be there.}

\begin{equation}\label{TopologyMutexFormula}
	\bigwedge \limits_{m \in \mathcal{M}} \LTLG \Big( \LTLX \pi_m^c \Leftrightarrow \bigwedge \limits_{m^\prime \neq m} \LTLX \lnot \pi_{m^\prime}^c \Big)
\end{equation}

The environment safety assumptions \eqref{SingleStepChangeFormula} govern how the active control mode can change in a single time step in response to the activation of a control mode transition.

\begin{equation}\label{SingleStepChangeFormula}
	\bigwedge \limits_{m \in \mathcal{M}} \bigwedge \limits_{m^\prime \in Adj(m)} \LTLG \Big( \pi_m^c \wedge  \varphi_{m^\prime} \Rightarrow \big( \LTLX \pi_{m}^c \bigvee \limits_{o \in Out(m^\prime)} \LTLX \pi_{m^\prime}^o \big) \Big)
\end{equation}

The environment safety assumptions \eqref{TopologyOutcomeConstraintFormula} constrain the outcomes control mode transitions.

\begin{equation}\label{TopologyOutcomeConstraintFormula}
	\bigwedge \limits_{m \in \mathcal{M}} \bigwedge \limits_{o \in Out(m)} \LTLG \Big( \lnot \pi_m^o \wedge \lnot \pi_m \Rightarrow \LTLX \lnot \pi_m^o \Big)
\end{equation}

The environment safety assumptions \eqref{TopologyOutcomePersistenceFormula} dictate that the value of the outcomes of control mode transitions must not change if no transition is being activated, i.e., they must persist.

\begin{equation}\label{TopologyOutcomePersistenceFormula}
	\bigwedge \limits_{m \in \mathcal{M}} \bigwedge \limits_{o \in Out(m)} \LTLG \Big( \pi_m^o \wedge \varphi_\mathcal{M}^{none} \Rightarrow \LTLX \pi_m^o \Big)
\end{equation}

The environment liveness assumption \eqref{TopologyFairnessConditionsFormula} is the equivalent of the fairness condition \eqref{ActionFairnessConditionsFormula} for control mode propositions.

\begin{subequations}
	\begin{align}
		\varphi_\mathcal{M}^{return} = &\bigvee \limits_{m \in \mathcal{M}} \Big( \varphi_m \wedge \bigvee \limits_{o \in Out(m)} \LTLX \pi_m^o \Big)\label{TopologyFairnessConditionsFormula1}\\
		\varphi_\mathcal{M}^{change} = &\bigvee \limits_{m \in \mathcal{M}} \Big( \varphi_m \wedge \LTLX \lnot \varphi_m \Big)\label{TopologyFairnessConditionsFormula2}\\
		\LTLG \LTLF \big( \varphi_\mathcal{M}^{return} &\vee \varphi_\mathcal{M}^{change} \vee \varphi_\mathcal{M}^{none} \big)\label{TopologyFairnessConditionsFormula}
	\end{align}
\end{subequations}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Initial Conditions}

For each action, $a$, and control mode, $m$, in the initial conditions, $\mathcal{I}$, the completion proposition should be \texttt{True} in the environment initial conditions \eqref{EnvironmentInitialConditions}.
All other outcome propositions corresponding to those actions and control modes, as well as all outcome propositions corresponding to any other actions and control modes, should be \texttt{False}.

\begin{equation}\label{EnvironmentInitialConditions}
	\varphi_i^e = \bigwedge \limits_{i \in \mathcal{I}} \Big( \pi_i^c \bigwedge \limits_{o \in Out(i)\backslash \{c\}} \lnot \pi_i^o \Big) \wedge \bigwedge \limits_{j \not\in \mathcal{I}} \bigwedge \limits_{o \in Out(j)} \lnot \pi_j^o
\end{equation}

Activation propositions are \texttt{False} regardless of whether that action or control mode is in the initial conditions or not \eqref{SystemInitialConditions}.
The reason being that, intuitively, if we want something to be an initial condition, then we shouldn't have the resulting controller re-activate it at the beginning of execution.

\begin{equation}\label{SystemInitialConditions}
	\varphi_i^s = \bigwedge \limits_{i \in \mathcal{I}} \lnot \pi_i \wedge \bigwedge \limits_{j \not \in \mathcal{I}} \lnot \pi_j
\end{equation}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Success and Failure}

The system initial condition \eqref{MemoryInitialCondition}, safety requirements \eqref{SuccessfulOutcomeFormulas}, and liveness requirement \eqref{SuccessLivenessFormula} are used to reason about the satisfaction of the system's goals, $\mathcal{G}$, in a finite run (as opposed to infinite execution, which is what LTL is defined over).
The proposition $\pi_{finished} \in Out(SM)$ in formula \eqref{SuccessfulOutcomeFormula} is one of those ``special" propositions.
\todo[inline, caption = {Make SM outcomes persistent}]{Technically, all $\pi_o,\; \forall o \in Out(SM)$ should also be persistent, like memory props \eqref{SuccessfulOutcomeFormula2}.}
\todo[inline, caption = {Differentiate between control modes and memory}]{I've been using $m$ to stand both for control modes $m \in \mathcal{M}$ and for memory propositions $m_g$. Fix.}

\begin{equation}\label{MemoryInitialCondition}
	\bigwedge \limits_{g \in \mathcal{G}} \lnot m_g 
\end{equation}

\begin{subequations}
	\label{SuccessfulOutcomeFormulas}
	\begin{align}
		\bigwedge \limits_{g \in \mathcal{G}} \LTLG \Big( \LTLX \pi_g^c &\Rightarrow \LTLX m_g \Big) \label{SuccessfulOutcomeFormula1}\\
		\bigwedge \limits_{g \in \mathcal{G}}\LTLG \Big(  m_g &\Rightarrow \LTLX m_g \Big) \label{SuccessfulOutcomeFormula2}\\
		\bigwedge \limits_{g \in \mathcal{G}}\LTLG \Big(  \lnot m_g \wedge \LTLX \lnot \pi_g^c &\Rightarrow \LTLX \lnot m_g \Big) \label{SuccessfulOutcomeFormula3}\\
		\LTLG \Big( \pi_{finished} &\Leftrightarrow \bigwedge \limits_{g \in \mathcal{G}} m_g \Big) \label{SuccessfulOutcomeFormula}
	\end{align}
\end{subequations}

\begin{equation}\label{SuccessLivenessFormula}
	\LTLG \LTLF \bigvee \limits_{o \in Out(SM)} \pi_{o}
\end{equation}

\todo[inline, caption = {Strict liveness requirement (goal) ordering}]{Come up with alternative formulation of \eqref{SuccessfulOutcomeFormulas} that enforces strict ordering on the liveness requirements.
It will be optional from the user's point-of-view.}


\subsection{Other subsection}

\ldots

%END