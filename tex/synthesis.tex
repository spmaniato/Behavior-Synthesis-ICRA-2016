% !TEX root = ../main.tex
\todo[inline, caption = {Title of section that solves Problem 3}]{Maybe rename this to ``Synthesis of Executable State Machines"? (Will depend on whether the term remains overloaded due to FlexBE ``behaviors".)}


We tackle Problem \ref{BehaviorSynthesisProblem} in two sequential steps.
First, we automatically generate a correct-by-construction automaton from the formal specification $\mathcal{T}_S$ using GR(1) synthesis (see \cite{piterman_06} and Section \ref{S:GR1}).
Specifically, we employ the synthesis algorithm in \cite{SLUGS}, which can handle a slightly larger fragment of LTL than GR(1).
Namely, the one that includes $\LTLX$ (next) operators in liveness formulas, such as in formulas \eqref{ActionFairnessConditionsFormula} and \eqref{TopologyFairnessConditionsFormula}.
This algorithm was first used in \cite{Vasu2013ICRA}.
\todo[inline, caption = {Properly mention SLUGS' fragment}]{@HKG, is it true that Vasu's paper was the first case of synthesis for this fragment? Had Ruediger used it before?}

\todo[inline, caption = {Relate $\gamma$ to FlexBE states}]{Say that, in our setup, the capabilities $\mathcal{C}$ are accessed via parametrized FlexBE states $\mathsf{S_P}$. Therefore \ldots}
Second, we use the mapping $\gamma: \mathcal{D} \rightarrow \mathcal{C}$ to instantiate the abstract automaton as a concrete software implementation, i.e., an executable state machine in the FlexBE framework introduced in Section \ref{S:FlexBE}.

% END