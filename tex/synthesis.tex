% !TEX root = ../main.tex

We tackle Problem \ref{BehaviorSynthesisProblem} in two sequential steps.
First, we automatically generate a correct-by-construction automaton from the formal specification $\mathcal{T}_S$ using GR(1) synthesis (see \cite{piterman_06} and Section \ref{S:GR1}).
Specifically, we employ the synthesis algorithm in \cite{SLUGS}, which can handle a slightly larger fragment of LTL than GR(1).
Namely, the one that includes $\LTLX$ (next) operators in liveness formulas, such as in formulas \eqref{ActionFairnessConditionsFormula} and \eqref{TopologyFairnessConditionsFormula}.
This algorithm was first used in \cite{Vasu2013ICRA}.
\todo[inline, caption = {Properly mention SLUGS' fragment}]{@HKG, is it true that Vasu's paper was the first case of synthesis for this fragment? Had Ruediger used it before?}

\todo[inline, caption = {Relate $\mathcal{D}_M$ to FlexBE in Synthesis?}]{If we are going down the generic route, then now would be the time to relate $\mathcal{D}_M$ to FlexBE states, right? Because in order to address Problem \ref{BehaviorSynthesisProblem}, we need the output of our solution to be a software implementation.}
Second, we use the mapping $\mathcal{D}_M: \mathcal{D} \rightarrow \mathcal{S}$ to instantiate the abstract automaton as a concrete software implementation, i.e., an executable state machine in the FlexBE framework introduced in Section \ref{S:FlexBE}.

% END